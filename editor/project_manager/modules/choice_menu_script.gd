# ChoiceMenu.gd
# Generated by Lupine Engine - Choice Menu UI Script
# Manages the choice display UI for the Choice System

extends Control

# UI references
@onready var choice_container = $ChoiceContainer
@onready var timer_label = $TimerLabel

# Choice button scene (you may want to create a separate scene for this)
var choice_button_scene = preload("res://scenes/ui/ChoiceButton.tscn") # Optional

# Current choices
var current_choices: Array = []
var choice_buttons: Array = []

func _ready():
	# Register this menu with the Choice System
	if ChoiceSystem:
		ChoiceSystem.register_choice_menu(self)
	
	# Hide initially
	visible = false
	print("Choice Menu UI initialized")

func _process(delta):
	# Update timer display if showing timed choices
	if ChoiceSystem and ChoiceSystem.is_choice_active():
		var remaining_time = ChoiceSystem.get_remaining_time()
		if remaining_time > 0:
			timer_label.text = "Time: " + str(int(remaining_time + 1))
			timer_label.visible = true
		else:
			timer_label.visible = false
	else:
		timer_label.visible = false

# Called by ChoiceSystem to update choices
func update_choices(choices: Array, is_timed: bool = false, time_limit: float = 0.0):
	current_choices = choices
	
	# Clear existing buttons
	clear_choice_buttons()
	
	# Create new choice buttons
	for i in range(choices.size()):
		var choice = choices[i]
		var button = create_choice_button(choice["text"], i)
		choice_buttons.append(button)
		choice_container.add_child(button)
	
	# Show the menu
	visible = true
	
	# Set up timer if timed choice
	if is_timed:
		timer_label.visible = true
		timer_label.text = "Time: " + str(int(time_limit))
	else:
		timer_label.visible = false

# Create a choice button
func create_choice_button(text: String, index: int) -> Button:
	var button = Button.new()
	button.text = text
	button.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	button.custom_minimum_size.y = 40
	
	# Connect button press
	button.pressed.connect(_on_choice_selected.bind(index))
	
	return button

# Handle choice selection
func _on_choice_selected(choice_index: int):
	if ChoiceSystem:
		ChoiceSystem.make_choice(choice_index)

# Called by ChoiceSystem to hide choices
func hide_choices():
	visible = false
	clear_choice_buttons()

# Clear all choice buttons
func clear_choice_buttons():
	for button in choice_buttons:
		if button and is_instance_valid(button):
			button.queue_free()
	choice_buttons.clear()
	
	# Clear container children
	for child in choice_container.get_children():
		child.queue_free()

# Handle keyboard input for choice selection
func _input(event):
	if not visible or current_choices.is_empty():
		return
	
	if event is InputEventKey and event.pressed:
		# Number keys 1-9 for quick choice selection
		if event.keycode >= KEY_1 and event.keycode <= KEY_9:
			var choice_index = event.keycode - KEY_1
			if choice_index < current_choices.size():
				_on_choice_selected(choice_index)
				get_viewport().set_input_as_handled()
