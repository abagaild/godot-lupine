#include "camera_3d_orbit_module.h"

void Camera3DOrbitModule::generate_script(Ref<FileAccess> p_file) {
	p_file->store_line("# Camera3DOrbit.gd");
	p_file->store_line("# Generated by Lupine Engine - 3D Third-Person Orbit Camera");
	p_file->store_line("# 3D third-person camera with orbit controls, zoom, and smooth following");
	p_file->store_line("");
	p_file->store_line("extends Node3D");
	p_file->store_line("class_name Camera3DOrbit");
	p_file->store_line("");
	p_file->store_line("# Camera settings");
	p_file->store_line("@export var mouse_sensitivity: float = 0.002");
	p_file->store_line("@export var follow_speed: float = 8.0");
	p_file->store_line("@export var rotation_speed: float = 5.0");
	p_file->store_line("");
	p_file->store_line("# Distance and zoom");
	p_file->store_line("@export var default_distance: float = 5.0");
	p_file->store_line("@export var min_distance: float = 1.0");
	p_file->store_line("@export var max_distance: float = 15.0");
	p_file->store_line("@export var zoom_speed: float = 2.0");
	p_file->store_line("@export var zoom_step: float = 0.5");
	p_file->store_line("@export var smooth_zoom: bool = true");
	p_file->store_line("");
	p_file->store_line("# Vertical rotation limits");
	p_file->store_line("@export var min_pitch: float = -80.0");
	p_file->store_line("@export var max_pitch: float = 80.0");
	p_file->store_line("");
	p_file->store_line("# Offset and collision");
	p_file->store_line("@export var camera_offset: Vector3 = Vector3(0, 1.5, 0)");
	p_file->store_line("@export var enable_collision: bool = true");
	p_file->store_line("@export var collision_mask: int = 1");
	p_file->store_line("");
	p_file->store_line("# Node references");
	p_file->store_line("@onready var camera: Camera3D = $Camera3D");
	p_file->store_line("");
	p_file->store_line("# State variables");
	p_file->store_line("var target: Node3D");
	p_file->store_line("var current_distance: float");
	p_file->store_line("var target_distance: float");
	p_file->store_line("var rotation_x: float = 0.0");
	p_file->store_line("var rotation_y: float = 0.0");
	p_file->store_line("var mouse_captured: bool = false");
	p_file->store_line("");
	p_file->store_line("# Signals");
	p_file->store_line("signal distance_changed(new_distance: float)");
	p_file->store_line("signal target_changed(new_target: Node3D)");
	p_file->store_line("");
	p_file->store_line("func _ready():");
	p_file->store_line("\tcurrent_distance = default_distance");
	p_file->store_line("\ttarget_distance = default_distance");
	p_file->store_line("\t");
	p_file->store_line("\t# Make camera current");
	p_file->store_line("\tif camera:");
	p_file->store_line("\t\tcamera.make_current()");
	p_file->store_line("\t");
	p_file->store_line("\t# Capture mouse initially");
	p_file->store_line("\tInput.mouse_mode = Input.MOUSE_MODE_CAPTURED");
	p_file->store_line("\tmouse_captured = true");
	p_file->store_line("");
	p_file->store_line("func _input(event):");
	p_file->store_line("\t# Toggle mouse capture");
	p_file->store_line("\tif Input.is_action_just_pressed(\"ui_cancel\"):");
	p_file->store_line("\t\ttoggle_mouse_capture()");
	p_file->store_line("\t");
	p_file->store_line("\t# Handle mouse movement for orbit");
	p_file->store_line("\tif event is InputEventMouseMotion and mouse_captured:");
	p_file->store_line("\t\trotation_y -= event.relative.x * mouse_sensitivity");
	p_file->store_line("\t\trotation_x -= event.relative.y * mouse_sensitivity");
	p_file->store_line("\t\trotation_x = clamp(rotation_x, deg_to_rad(min_pitch), deg_to_rad(max_pitch))");
	p_file->store_line("\t");
	p_file->store_line("\t# Handle zoom input");
	p_file->store_line("\tif Input.is_action_just_pressed(\"zoom_in\"):");
	p_file->store_line("\t\ttarget_distance = clamp(target_distance - zoom_step, min_distance, max_distance)");
	p_file->store_line("\t\tdistance_changed.emit(target_distance)");
	p_file->store_line("\telif Input.is_action_just_pressed(\"zoom_out\"):");
	p_file->store_line("\t\ttarget_distance = clamp(target_distance + zoom_step, min_distance, max_distance)");
	p_file->store_line("\t\tdistance_changed.emit(target_distance)");
	p_file->store_line("\t");
	p_file->store_line("\t# Reset distance");
	p_file->store_line("\tif Input.is_action_just_pressed(\"reset_zoom\"):");
	p_file->store_line("\t\ttarget_distance = default_distance");
	p_file->store_line("\t\tdistance_changed.emit(target_distance)");
	p_file->store_line("");
	p_file->store_line("func _process(delta: float):");
	p_file->store_line("\tif not target:");
	p_file->store_line("\t\treturn");
	p_file->store_line("\t");
	p_file->store_line("\t# Smooth zoom");
	p_file->store_line("\tif smooth_zoom:");
	p_file->store_line("\t\tcurrent_distance = lerp(current_distance, target_distance, zoom_speed * delta)");
	p_file->store_line("\telse:");
	p_file->store_line("\t\tcurrent_distance = target_distance");
	p_file->store_line("\t");
	p_file->store_line("\t# Follow target");
	p_file->store_line("\t_follow_target(delta)");
	p_file->store_line("\t");
	p_file->store_line("\t# Update camera position");
	p_file->store_line("\t_update_camera_position()");
	p_file->store_line("");
	p_file->store_line("func _follow_target(delta: float):");
	p_file->store_line("\tvar target_position = target.global_position + camera_offset");
	p_file->store_line("\tglobal_position = global_position.lerp(target_position, follow_speed * delta)");
	p_file->store_line("");
	p_file->store_line("func _update_camera_position():");
	p_file->store_line("\t# Calculate camera position based on rotation and distance");
	p_file->store_line("\tvar offset = Vector3.ZERO");
	p_file->store_line("\toffset.z = current_distance");
	p_file->store_line("\t");
	p_file->store_line("\t# Apply rotations");
	p_file->store_line("\toffset = offset.rotated(Vector3.UP, rotation_y)");
	p_file->store_line("\toffset = offset.rotated(Vector3.RIGHT, rotation_x)");
	p_file->store_line("\t");
	p_file->store_line("\t# Handle collision if enabled");
	p_file->store_line("\tvar final_distance = current_distance");
	p_file->store_line("\tif enable_collision:");
	p_file->store_line("\t\tfinal_distance = _check_collision(offset)");
	p_file->store_line("\t\toffset = offset.normalized() * final_distance");
	p_file->store_line("\t");
	p_file->store_line("\t# Set camera position and look at target");
	p_file->store_line("\tif camera:");
	p_file->store_line("\t\tcamera.global_position = global_position + offset");
	p_file->store_line("\t\tcamera.look_at(global_position, Vector3.UP)");
	p_file->store_line("");
	p_file->store_line("func _check_collision(offset: Vector3) -> float:");
	p_file->store_line("\tvar space_state = get_world_3d().direct_space_state");
	p_file->store_line("\tvar query = PhysicsRayQueryParameters3D.create(");
	p_file->store_line("\t\tglobal_position,");
	p_file->store_line("\t\tglobal_position + offset");
	p_file->store_line("\t)");
	p_file->store_line("\tquery.collision_mask = collision_mask");
	p_file->store_line("\t");
	p_file->store_line("\tvar result = space_state.intersect_ray(query)");
	p_file->store_line("\tif result:");
	p_file->store_line("\t\tvar hit_distance = global_position.distance_to(result.position)");
	p_file->store_line("\t\treturn max(hit_distance - 0.1, min_distance)  # Small offset to avoid clipping");
	p_file->store_line("\t");
	p_file->store_line("\treturn current_distance");
	p_file->store_line("");
	p_file->store_line("# Public methods");
	p_file->store_line("func set_target(new_target: Node3D):");
	p_file->store_line("\ttarget = new_target");
	p_file->store_line("\ttarget_changed.emit(new_target)");
	p_file->store_line("");
	p_file->store_line("func set_distance(new_distance: float):");
	p_file->store_line("\ttarget_distance = clamp(new_distance, min_distance, max_distance)");
	p_file->store_line("\tdistance_changed.emit(target_distance)");
	p_file->store_line("");
	p_file->store_line("func toggle_mouse_capture():");
	p_file->store_line("\tmouse_captured = not mouse_captured");
	p_file->store_line("\tInput.mouse_mode = Input.MOUSE_MODE_CAPTURED if mouse_captured else Input.MOUSE_MODE_VISIBLE");
	p_file->store_line("");
	p_file->store_line("func get_current_distance() -> float:");
	p_file->store_line("\treturn current_distance");
	p_file->store_line("");
	p_file->store_line("func reset_to_default():");
	p_file->store_line("\ttarget_distance = default_distance");
	p_file->store_line("\trotation_x = 0.0");
	p_file->store_line("\trotation_y = 0.0");
}

void Camera3DOrbitModule::generate_scene(Ref<FileAccess> p_file, const String &p_scene_name) {
	p_file->store_line("[gd_scene load_steps=2 format=3 uid=\"uid://camera_3d_orbit\"]");
	p_file->store_line("");
	p_file->store_line("[ext_resource type=\"Script\" path=\"res://scripts/Camera3DOrbit.gd\" id=\"1_camera_script\"]");
	p_file->store_line("");
	p_file->store_line("[node name=\"" + p_scene_name + "\" type=\"Node3D\"]");
	p_file->store_line("script = ExtResource(\"1_camera_script\")");
	p_file->store_line("");
	p_file->store_line("[node name=\"Camera3D\" type=\"Camera3D\" parent=\".\"]");
	p_file->store_line("transform = Transform3D(1, 0, 0, 0, 0.866025, 0.5, 0, -0.5, 0.866025, 0, 2, 5)");
}
