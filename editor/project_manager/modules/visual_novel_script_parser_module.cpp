#include "visual_novel_script_parser_module.h"

void VisualNovelScriptParserModule::generate_script(Ref<FileAccess> p_file) {
	p_file->store_line("# VNScriptParser.gd");
	p_file->store_line("# Generated by Lupine Engine - Visual Novel Script Parser");
	p_file->store_line("# Writer-forward script parser with node-based dialogue system");
	p_file->store_line("");
	p_file->store_line("extends Node");
	p_file->store_line("");
	p_file->store_line("# Signals for script events");
	p_file->store_line("signal dialogue_started(character_name: String, text: String)");
	p_file->store_line("signal dialogue_ended()");
	p_file->store_line("signal choice_presented(choices: Array)");
	p_file->store_line("signal command_executed(command: String, args: Array)");
	p_file->store_line("signal script_finished()");
	p_file->store_line("signal variable_changed(var_name: String, value)");
	p_file->store_line("");
	p_file->store_line("# Current script state");
	p_file->store_line("var current_script: Dictionary = {}");
	p_file->store_line("var current_node_id: String = \"\"");
	p_file->store_line("var script_variables: Dictionary = {}");
	p_file->store_line("var script_functions: Dictionary = {}");
	p_file->store_line("");
	p_file->store_line("# Asset paths for automatic discovery");
	p_file->store_line("var asset_paths = {");
	p_file->store_line("\t\"backgrounds\": \"assets/backgrounds\",");
	p_file->store_line("\t\"portraits\": \"assets/portraits\",");
	p_file->store_line("\t\"music\": \"assets/music\",");
	p_file->store_line("\t\"soundEffects\": \"assets/soundEffects\"");
	p_file->store_line("}");
	p_file->store_line("");
	p_file->store_line("func _ready():");
	p_file->store_line("\t# Initialize script parser");
	p_file->store_line("\tprint(\"VN Script Parser initialized\")");
	p_file->store_line("");
	p_file->store_line("# Load and parse a visual novel script file");
	p_file->store_line("func load_script(script_path: String) -> bool:");
	p_file->store_line("\tvar file = FileAccess.open(script_path, FileAccess.READ)");
	p_file->store_line("\tif not file:");
	p_file->store_line("\t\tprint(\"Failed to load script: \", script_path)");
	p_file->store_line("\t\treturn false");
	p_file->store_line("\t");
	p_file->store_line("\tvar content = file.get_as_text()");
	p_file->store_line("\tfile.close()");
	p_file->store_line("\t");
	p_file->store_line("\tcurrent_script = parse_script_content(content)");
	p_file->store_line("\treturn current_script.size() > 0");
	p_file->store_line("");
	p_file->store_line("# Parse script content into node structure");
	p_file->store_line("func parse_script_content(content: String) -> Dictionary:");
	p_file->store_line("\tvar script_data = {}");
	p_file->store_line("\tvar lines = content.split(\"\\n\")");
	p_file->store_line("\tvar current_function = \"\"");
	p_file->store_line("\tvar i = 0");
	p_file->store_line("\t");
	p_file->store_line("\twhile i < lines.size():");
	p_file->store_line("\t\tvar line = lines[i].strip_edges()");
	p_file->store_line("\t\t");
	p_file->store_line("\t\t# Skip empty lines and comments");
	p_file->store_line("\t\tif line.is_empty() or line.begins_with(\"#\"):");
	p_file->store_line("\t\t\ti += 1");
	p_file->store_line("\t\t\tcontinue");
	p_file->store_line("\t\t");
	p_file->store_line("\t\t# Function declaration (FN : FunctionName)");
	p_file->store_line("\t\tif line.begins_with(\"FN :\"):");
	p_file->store_line("\t\t\tcurrent_function = line.substr(4).strip_edges()");
	p_file->store_line("\t\t\tscript_functions[current_function] = {}");
	p_file->store_line("\t\t\ti += 1");
	p_file->store_line("\t\t\tcontinue");
	p_file->store_line("\t\t");
	p_file->store_line("\t\t# Commands [[command args]]");
	p_file->store_line("\t\tif line.begins_with(\"[[\") and line.ends_with(\"]]\"):");
	p_file->store_line("\t\t\t# Handle commands in current function context");
	p_file->store_line("\t\t\ti += 1");
	p_file->store_line("\t\t\tcontinue");
	p_file->store_line("\t\t");
	p_file->store_line("\t\t# Node definition (NodeID or NodeID if condition)");
	p_file->store_line("\t\tif not line.contains(\" \") or line.split(\" \")[0].is_valid_identifier():");
	p_file->store_line("\t\t\tvar node_data = parse_node(lines, i)");
	p_file->store_line("\t\t\tif current_function.is_empty():");
	p_file->store_line("\t\t\t\tscript_data[node_data.id] = node_data");
	p_file->store_line("\t\t\telse:");
	p_file->store_line("\t\t\t\tscript_functions[current_function][node_data.id] = node_data");
	p_file->store_line("\t\t\ti = node_data.end_line");
	p_file->store_line("\t\t\tcontinue");
	p_file->store_line("\t\t");
	p_file->store_line("\t\ti += 1");
	p_file->store_line("\t");
	p_file->store_line("\treturn script_data");
	p_file->store_line("");
	p_file->store_line("# Parse a single dialogue node");
	p_file->store_line("func parse_node(lines: PackedStringArray, start_index: int) -> Dictionary:");
	p_file->store_line("\tvar node = {");
	p_file->store_line("\t\t\"id\": \"\",");
	p_file->store_line("\t\t\"condition\": \"\",");
	p_file->store_line("\t\t\"speaker\": \"\",");
	p_file->store_line("\t\t\"dialogue\": [],");
	p_file->store_line("\t\t\"commands\": [],");
	p_file->store_line("\t\t\"choices\": [],");
	p_file->store_line("\t\t\"next_node\": \"\",");
	p_file->store_line("\t\t\"end_line\": start_index");
	p_file->store_line("\t}");
	p_file->store_line("\t");
	p_file->store_line("\tvar line = lines[start_index].strip_edges()");
	p_file->store_line("\t");
	p_file->store_line("\t# Parse node ID and condition");
	p_file->store_line("\tif \" if \" in line:");
	p_file->store_line("\t\tvar parts = line.split(\" if \", false, 1)");
	p_file->store_line("\t\tnode.id = parts[0].strip_edges()");
	p_file->store_line("\t\tnode.condition = parts[1].strip_edges()");
	p_file->store_line("\telse:");
	p_file->store_line("\t\tnode.id = line");
	p_file->store_line("\t");
	p_file->store_line("\tvar i = start_index + 1");
	p_file->store_line("\tvar parsing_dialogue = false");
	p_file->store_line("\t");
	p_file->store_line("\twhile i < lines.size():");
	p_file->store_line("\t\tline = lines[i].strip_edges()");
	p_file->store_line("\t\t");
	p_file->store_line("\t\t# Empty line or next node - end parsing");
	p_file->store_line("\t\tif line.is_empty() or (not parsing_dialogue and line.split(\" \")[0].is_valid_identifier()):");
	p_file->store_line("\t\t\tbreak");
	p_file->store_line("\t\t");
	p_file->store_line("\t\t# Commands");
	p_file->store_line("\t\tif line.begins_with(\"[[\") and line.ends_with(\"]]\"):");
	p_file->store_line("\t\t\tnode.commands.append(line.substr(2, line.length() - 4))");
	p_file->store_line("\t\t\ti += 1");
	p_file->store_line("\t\t\tcontinue");
	p_file->store_line("\t\t");
	p_file->store_line("\t\t# Choices [Choice|NodeID]");
	p_file->store_line("\t\tif line.begins_with(\"[\") and \"|\" in line and line.ends_with(\"]\"):");
	p_file->store_line("\t\t\tvar choice_content = line.substr(1, line.length() - 2)");
	p_file->store_line("\t\t\tvar choice_parts = choice_content.split(\"|\", false, 1)");
	p_file->store_line("\t\t\tnode.choices.append({");
	p_file->store_line("\t\t\t\t\"text\": choice_parts[0].strip_edges(),");
	p_file->store_line("\t\t\t\t\"target\": choice_parts[1].strip_edges()");
	p_file->store_line("\t\t\t})");
	p_file->store_line("\t\t\ti += 1");
	p_file->store_line("\t\t\tcontinue");
	p_file->store_line("\t\t");
	p_file->store_line("\t\t# Simple node connection [NodeID]");
	p_file->store_line("\t\tif line.begins_with(\"[\") and line.ends_with(\"]\") and not \"|\" in line:");
	p_file->store_line("\t\t\tnode.next_node = line.substr(1, line.length() - 2)");
	p_file->store_line("\t\t\ti += 1");
	p_file->store_line("\t\t\tcontinue");
	p_file->store_line("\t\t");
	p_file->store_line("\t\t# End marker");
	p_file->store_line("\t\tif line == \"[end]\":");
	p_file->store_line("\t\t\tnode.next_node = \"end\"");
	p_file->store_line("\t\t\ti += 1");
	p_file->store_line("\t\t\tbreak");
	p_file->store_line("\t\t");
	p_file->store_line("\t\t# Speaker or dialogue");
	p_file->store_line("\t\tif not parsing_dialogue:");
	p_file->store_line("\t\t\t# First non-command line is speaker");
	p_file->store_line("\t\t\tnode.speaker = format_character_name(line)");
	p_file->store_line("\t\t\tparsing_dialogue = true");
	p_file->store_line("\t\telse:");
	p_file->store_line("\t\t\t# Subsequent lines are dialogue");
	p_file->store_line("\t\t\tnode.dialogue.append(line)");
	p_file->store_line("\t\t");
	p_file->store_line("\t\ti += 1");
	p_file->store_line("\t");
	p_file->store_line("\tnode.end_line = i");
	p_file->store_line("\treturn node");
	p_file->store_line("");
	p_file->store_line("# Format character names (DamienWayne_happy -> Damien Wayne)");
	p_file->store_line("func format_character_name(name: String) -> String:");
	p_file->store_line("\tif name.is_empty():");
	p_file->store_line("\t\treturn \"\"");
	p_file->store_line("\t");
	p_file->store_line("\t# Remove emotion suffix");
	p_file->store_line("\tvar clean_name = name");
	p_file->store_line("\tif \"_\" in clean_name:");
	p_file->store_line("\t\tclean_name = clean_name.split(\"_\")[0]");
	p_file->store_line("\t");
	p_file->store_line("\t# Convert PascalCase to spaced name");
	p_file->store_line("\tvar result = \"\"");
	p_file->store_line("\tfor i in range(clean_name.length()):");
	p_file->store_line("\t\tvar char = clean_name[i]");
	p_file->store_line("\t\tif i > 0 and char.to_upper() == char and char.is_valid_identifier():");
	p_file->store_line("\t\t\tresult += \" \"");
	p_file->store_line("\t\tresult += char");
	p_file->store_line("\t");
	p_file->store_line("\treturn result");
	p_file->store_line("");
	p_file->store_line("# Execute a script starting from a specific node");
	p_file->store_line("func start_script(start_node: String = \"1_1\"):");
	p_file->store_line("\tcurrent_node_id = start_node");
	p_file->store_line("\texecute_current_node()");
	p_file->store_line("");
	p_file->store_line("# Execute the current node");
	p_file->store_line("func execute_current_node():");
	p_file->store_line("\tif current_node_id == \"end\":");
	p_file->store_line("\t\tscript_finished.emit()");
	p_file->store_line("\t\treturn");
	p_file->store_line("\t");
	p_file->store_line("\t# Find the appropriate node (check conditions)");
	p_file->store_line("\tvar node = find_valid_node(current_node_id)");
	p_file->store_line("\tif not node:");
	p_file->store_line("\t\tprint(\"Node not found: \", current_node_id)");
	p_file->store_line("\t\tscript_finished.emit()");
	p_file->store_line("\t\treturn");
	p_file->store_line("\t");
	p_file->store_line("\t# Execute commands");
	p_file->store_line("\tfor command in node.commands:");
	p_file->store_line("\t\texecute_command(command)");
	p_file->store_line("\t");
	p_file->store_line("\t# Handle dialogue");
	p_file->store_line("\tif node.dialogue.size() > 0:");
	p_file->store_line("\t\tvar full_dialogue = \"\"");
	p_file->store_line("\t\tfor line in node.dialogue:");
	p_file->store_line("\t\t\tfull_dialogue += line + \"\\n\"");
	p_file->store_line("\t\tfull_dialogue = full_dialogue.strip_edges()");
	p_file->store_line("\t\tdialogue_started.emit(node.speaker, full_dialogue)");
	p_file->store_line("\t");
	p_file->store_line("\t# Handle choices or auto-advance");
	p_file->store_line("\tif node.choices.size() > 0:");
	p_file->store_line("\t\tchoice_presented.emit(node.choices)");
	p_file->store_line("\telse:");
	p_file->store_line("\t\t# Auto-advance to next node");
	p_file->store_line("\t\tif not node.next_node.is_empty():");
	p_file->store_line("\t\t\tcurrent_node_id = node.next_node");
	p_file->store_line("\t\telse:");
	p_file->store_line("\t\t\tscript_finished.emit()");
	p_file->store_line("");
	p_file->store_line("# Continue to next node (called after dialogue display)");
	p_file->store_line("func continue_script():");
	p_file->store_line("\tvar node = find_valid_node(current_node_id)");
	p_file->store_line("\tif node and node.choices.size() == 0:");
	p_file->store_line("\t\tif not node.next_node.is_empty():");
	p_file->store_line("\t\t\tcurrent_node_id = node.next_node");
	p_file->store_line("\t\t\texecute_current_node()");
	p_file->store_line("\t\telse:");
	p_file->store_line("\t\t\tscript_finished.emit()");
	p_file->store_line("");
	p_file->store_line("# Make a choice and continue");
	p_file->store_line("func make_choice(choice_index: int):");
	p_file->store_line("\tvar node = find_valid_node(current_node_id)");
	p_file->store_line("\tif node and choice_index < node.choices.size():");
	p_file->store_line("\t\tcurrent_node_id = node.choices[choice_index].target");
	p_file->store_line("\t\texecute_current_node()");
	p_file->store_line("");
	p_file->store_line("# Find a valid node considering conditions");
	p_file->store_line("func find_valid_node(node_id: String) -> Dictionary:");
	p_file->store_line("\t# Check main script first");
	p_file->store_line("\tfor key in current_script.keys():");
	p_file->store_line("\t\tif key == node_id or key.begins_with(node_id + \" if \"):");
	p_file->store_line("\t\t\tvar node = current_script[key]");
	p_file->store_line("\t\t\tif node.condition.is_empty() or evaluate_condition(node.condition):");
	p_file->store_line("\t\t\t\treturn node");
	p_file->store_line("\t");
	p_file->store_line("\t# Check functions");
	p_file->store_line("\tfor func_name in script_functions.keys():");
	p_file->store_line("\t\tvar func_nodes = script_functions[func_name]");
	p_file->store_line("\t\tfor key in func_nodes.keys():");
	p_file->store_line("\t\t\tif key == node_id or key.begins_with(node_id + \" if \"):");
	p_file->store_line("\t\t\t\tvar node = func_nodes[key]");
	p_file->store_line("\t\t\t\tif node.condition.is_empty() or evaluate_condition(node.condition):");
	p_file->store_line("\t\t\t\t\treturn node");
	p_file->store_line("\t");
	p_file->store_line("\treturn {}");
	p_file->store_line("");
	p_file->store_line("# Evaluate conditional expressions");
	p_file->store_line("func evaluate_condition(condition: String) -> bool:");
	p_file->store_line("\t# Simple condition evaluation - can be expanded");
	p_file->store_line("\t# Supports: var = value, var > value, var < value, var >= value, var <= value");
	p_file->store_line("\t# Also supports: and, or operators");
	p_file->store_line("\t");
	p_file->store_line("\tvar parts = condition.split(\" and \")");
	p_file->store_line("\tfor part in parts:");
	p_file->store_line("\t\tif not evaluate_single_condition(part.strip_edges()):");
	p_file->store_line("\t\t\treturn false");
	p_file->store_line("\treturn true");
	p_file->store_line("");
	p_file->store_line("func evaluate_single_condition(condition: String) -> bool:");
	p_file->store_line("\t# Parse single condition");
	p_file->store_line("\tvar operators = [\">=\", \"<=\", \"=\", \">\", \"<\"]");
	p_file->store_line("\t");
	p_file->store_line("\tfor op in operators:");
	p_file->store_line("\t\tif op in condition:");
	p_file->store_line("\t\t\tvar parts = condition.split(op, false, 1)");
	p_file->store_line("\t\t\tif parts.size() == 2:");
	p_file->store_line("\t\t\t\tvar var_name = parts[0].strip_edges()");
	p_file->store_line("\t\t\t\tvar value = parts[1].strip_edges()");
	p_file->store_line("\t\t\t\treturn compare_values(get_variable(var_name), value, op)");
	p_file->store_line("\t");
	p_file->store_line("\treturn false");
	p_file->store_line("");
	p_file->store_line("func compare_values(var_value, target_value: String, operator: String) -> bool:");
	p_file->store_line("\t# Convert target value to appropriate type");
	p_file->store_line("\tvar target");
	p_file->store_line("\tif target_value.is_valid_int():");
	p_file->store_line("\t\ttarget = target_value.to_int()");
	p_file->store_line("\telif target_value.is_valid_float():");
	p_file->store_line("\t\ttarget = target_value.to_float()");
	p_file->store_line("\telse:");
	p_file->store_line("\t\ttarget = target_value");
	p_file->store_line("\t");
	p_file->store_line("\tmatch operator:");
	p_file->store_line("\t\t\"=\":");
	p_file->store_line("\t\t\treturn var_value == target");
	p_file->store_line("\t\t\">\":");
	p_file->store_line("\t\t\treturn var_value > target");
	p_file->store_line("\t\t\"<\":");
	p_file->store_line("\t\t\treturn var_value < target");
	p_file->store_line("\t\t\">=\":");
	p_file->store_line("\t\t\treturn var_value >= target");
	p_file->store_line("\t\t\"<=\":");
	p_file->store_line("\t\t\treturn var_value <= target");
	p_file->store_line("\t\t_:");
	p_file->store_line("\t\t\treturn false");
	p_file->store_line("");
	p_file->store_line("# Execute script commands");
	p_file->store_line("func execute_command(command: String):");
	p_file->store_line("\tvar parts = command.split(\" \", false, 1)");
	p_file->store_line("\tvar cmd = parts[0]");
	p_file->store_line("\tvar args = []");
	p_file->store_line("\tif parts.size() > 1:");
	p_file->store_line("\t\targs = parts[1].split(\" \")");
	p_file->store_line("\t");
	p_file->store_line("\tmatch cmd:");
	p_file->store_line("\t\t\"var\":");
	p_file->store_line("\t\t\tif args.size() >= 1 and \"=\" in args[0]:");
	p_file->store_line("\t\t\t\tvar assignment = parts[1]");
	p_file->store_line("\t\t\t\tvar assign_parts = assignment.split(\"=\", false, 1)");
	p_file->store_line("\t\t\t\tif assign_parts.size() == 2:");
	p_file->store_line("\t\t\t\t\tvar var_name = assign_parts[0].strip_edges()");
	p_file->store_line("\t\t\t\t\tvar value = assign_parts[1].strip_edges()");
	p_file->store_line("\t\t\t\t\tset_variable(var_name, value)");
	p_file->store_line("\t\t\"signal\":");
	p_file->store_line("\t\t\tif args.size() > 0:");
	p_file->store_line("\t\t\t\t# Emit global signal");
	p_file->store_line("\t\t\t\tvar signal_name = args[0]");
	p_file->store_line("\t\t\t\tvar signal_args = args.slice(1) if args.size() > 1 else []");
	p_file->store_line("\t\t\t\tget_tree().call_group(\"vn_listeners\", \"_on_vn_signal\", signal_name, signal_args)");
	p_file->store_line("\t\t_:");
	p_file->store_line("\t\t\t# Other commands handled by external systems");
	p_file->store_line("\t\t\tcommand_executed.emit(cmd, args)");
	p_file->store_line("");
	p_file->store_line("# Variable management");
	p_file->store_line("func set_variable(name: String, value):");
	p_file->store_line("\t# Convert string values to appropriate types");
	p_file->store_line("\tif value is String:");
	p_file->store_line("\t\tif value.is_valid_int():");
	p_file->store_line("\t\t\tvalue = value.to_int()");
	p_file->store_line("\t\telif value.is_valid_float():");
	p_file->store_line("\t\t\tvalue = value.to_float()");
	p_file->store_line("\t\telif value.to_lower() == \"true\":");
	p_file->store_line("\t\t\tvalue = true");
	p_file->store_line("\t\telif value.to_lower() == \"false\":");
	p_file->store_line("\t\t\tvalue = false");
	p_file->store_line("\t");
	p_file->store_line("\tscript_variables[name] = value");
	p_file->store_line("\tvariable_changed.emit(name, value)");
	p_file->store_line("");
	p_file->store_line("func get_variable(name: String):");
	p_file->store_line("\treturn script_variables.get(name, null)");
	p_file->store_line("");
	p_file->store_line("# Asset discovery helpers");
	p_file->store_line("func find_asset(asset_name: String, asset_type: String) -> String:");
	p_file->store_line("\tvar base_path = asset_paths.get(asset_type, \"\")");
	p_file->store_line("\tif base_path.is_empty():");
	p_file->store_line("\t\treturn \"\"");
	p_file->store_line("\t");
	p_file->store_line("\t# Common extensions by type");
	p_file->store_line("\tvar extensions = []");
	p_file->store_line("\tmatch asset_type:");
	p_file->store_line("\t\t\"music\":");
	p_file->store_line("\t\t\textensions = [\".mp3\", \".wav\", \".ogg\"]");
	p_file->store_line("\t\t\"soundEffects\":");
	p_file->store_line("\t\t\textensions = [\".wav\", \".mp3\", \".ogg\"]");
	p_file->store_line("\t\t\"backgrounds\":");
	p_file->store_line("\t\t\textensions = [\".png\", \".jpg\", \".jpeg\", \".webp\"]");
	p_file->store_line("\t\t\"portraits\":");
	p_file->store_line("\t\t\textensions = [\".png\", \".jpg\", \".jpeg\", \".webp\"]");
	p_file->store_line("\t\t_:");
	p_file->store_line("\t\t\textensions = [\".png\", \".jpg\", \".mp3\", \".wav\"]");
	p_file->store_line("\t");
	p_file->store_line("\t# Try to find file with various extensions");
	p_file->store_line("\tfor ext in extensions:");
	p_file->store_line("\t\tvar full_path = base_path + \"/\" + asset_name + ext");
	p_file->store_line("\t\tif FileAccess.file_exists(full_path):");
	p_file->store_line("\t\t\treturn full_path");
	p_file->store_line("\t");
	p_file->store_line("\t# If not found, return the asset name as-is (might be a full path)");
	p_file->store_line("\treturn asset_name");
}

void VisualNovelScriptParserModule::generate_file(Ref<FileAccess> p_file, const String &p_relative_path) {
	String filename = p_relative_path.get_file();

	if (filename == "example_conversation.vn") {
		// Generate the example visual novel script
		p_file->store_line("# example_conversation.vn");
		p_file->store_line("# Generated by Lupine Engine - Example Visual Novel Script");
		p_file->store_line("# Demonstrates the writer-forward script format with node-based dialogue");
		p_file->store_line("");
		p_file->store_line("FN : Conversation");
		p_file->store_line("");
		p_file->store_line("[[background school_courtyard]]");
		p_file->store_line("");
		p_file->store_line("[[setLeft Char1_neutral]]");
		p_file->store_line("[[setRight Char2_neutral]]");
		p_file->store_line("");
		p_file->store_line("1_1");
		p_file->store_line("Char2");
		p_file->store_line("Hey Char1! How are you doing?");
		p_file->store_line("[Good!|2_1]");
		p_file->store_line("[Bad!|2_2]");
		p_file->store_line("");
		p_file->store_line("2_1");
		p_file->store_line("Char2_happy");
		p_file->store_line("That's great!");
		p_file->store_line("[[var mood = good]]");
		p_file->store_line("[3_1]");
		p_file->store_line("");
		p_file->store_line("2_2");
		p_file->store_line("Char2_sad");
		p_file->store_line("Oh, I'm sorry");
		p_file->store_line("[[var mood = bad]]");
		p_file->store_line("[3_1]");
		p_file->store_line("");
		p_file->store_line("3_1 if mood = good");
		p_file->store_line("Char2_happy");
		p_file->store_line("I'm doing good as well!");
		p_file->store_line("[[signal char2Happy]]");
		p_file->store_line("[end]");
		p_file->store_line("");
		p_file->store_line("3_1 if mood = bad");
		p_file->store_line("Char2_sad");
		p_file->store_line("At least I'm doing better...");
		p_file->store_line("[[signal char2Sad]]");
		p_file->store_line("[end]");
		p_file->store_line("");
		p_file->store_line("# Example with more complex features");
		p_file->store_line("FN : ComplexExample");
		p_file->store_line("");
		p_file->store_line("[[background classroom]]");
		p_file->store_line("[[playMusic school_theme]]");
		p_file->store_line("");
		p_file->store_line("start_1");
		p_file->store_line("Teacher");
		p_file->store_line("Welcome to class! Today we'll learn about variables.");
		p_file->store_line("[[var lesson_started = true]]");
		p_file->store_line("[choice_1]");
		p_file->store_line("");
		p_file->store_line("choice_1");
		p_file->store_line("Teacher");
		p_file->store_line("What would you like to learn about first?");
		p_file->store_line("[Variables|var_lesson]");
		p_file->store_line("[Functions|func_lesson]");
		p_file->store_line("[Skip class|skip_class]");
		p_file->store_line("");
		p_file->store_line("var_lesson");
		p_file->store_line("Teacher_happy");
		p_file->store_line("Great choice! Variables store data.");
		p_file->store_line("[[var learned_variables = true]]");
		p_file->store_line("[[characterEffect bounce,left]]");
		p_file->store_line("[quiz_1]");
		p_file->store_line("");
		p_file->store_line("func_lesson");
		p_file->store_line("Teacher_excited");
		p_file->store_line("Functions are reusable code blocks!");
		p_file->store_line("[[var learned_functions = true]]");
		p_file->store_line("[[characterEffect glow,left]]");
		p_file->store_line("[quiz_1]");
		p_file->store_line("");
		p_file->store_line("skip_class");
		p_file->store_line("Teacher_disappointed");
		p_file->store_line("That's unfortunate. You'll miss important information.");
		p_file->store_line("[[var skipped_class = true]]");
		p_file->store_line("[[playSound disappointed_sigh]]");
		p_file->store_line("[end]");
		p_file->store_line("");
		p_file->store_line("quiz_1 if learned_variables = true");
		p_file->store_line("Teacher");
		p_file->store_line("Quick quiz: What do variables do?");
		p_file->store_line("[Store data|correct_1]");
		p_file->store_line("[Run code|wrong_1]");
		p_file->store_line("");
		p_file->store_line("quiz_1 if learned_functions = true");
		p_file->store_line("Teacher");
		p_file->store_line("Quick quiz: What do functions do?");
		p_file->store_line("[Store data|wrong_1]");
		p_file->store_line("[Run reusable code|correct_1]");
		p_file->store_line("");
		p_file->store_line("correct_1");
		p_file->store_line("Teacher_happy");
		p_file->store_line("Excellent! You were paying attention.");
		p_file->store_line("[[var quiz_passed = true]]");
		p_file->store_line("[[signal studentSuccess]]");
		p_file->store_line("[end]");
		p_file->store_line("");
		p_file->store_line("wrong_1");
		p_file->store_line("Teacher_neutral");
		p_file->store_line("Not quite right, but that's okay. Keep studying!");
		p_file->store_line("[[var quiz_passed = false]]");
		p_file->store_line("[end]");
	} else {
		// Use default file generation
		LupineModuleBase::generate_file(p_file, p_relative_path);
	}
}

void VisualNovelScriptParserModule::generate_scene(Ref<FileAccess> p_file, const String &p_scene_name) {
	// This module doesn't generate scenes, only scripts
	p_file->store_line("# VNScriptParser scene - not used");
}
